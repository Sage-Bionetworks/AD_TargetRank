---
title: Covariate and analysis of MSBB reprocessed counts Regressing out Diagnosis as well for TWAS
author: 'JKG - Adapted from: Thanneer Perumal'
output: html_notebook
editor_options:
  chunk_output_type: console
---
  Date of analysis update: "`r date()`"
  
| *Synapse ID* | *File Name* |
|  -----------------------------------------  |   ---------                      |
| Old Count Matrix ------syn8691099.1 | |
| syn20963389 | |
| syn20963390 | |
| syn10156693.3 | | 
| Old Metrics------syn8698270.1 | |
| syn20963391 | | 
| Old Length GC Data-----syn8449369.2 | | 
| syn21156161 | |
| syn6100548.7 | | 
| syn6101474.4 | | 

```{r libs, echo=FALSE, warning=FALSE, message=FALSE, include=FALSE, cache=FALSE}
##It is assumed your working directory is "~/ampad-DiffExp/gene_level_analysis"
## Load required libraries
library(CovariateAnalysis) # get the package from devtools::install_github('th1vairam/CovariateAnalysis@dev')
library(data.table)
library(plyr)
library(tidyverse)
library(psych)
library(limma)
library(edgeR)
#BiocManager::install("biomaRt")
library(biomaRt)
library(RColorBrewer)
library(cqn)
library(glmnet)
library(knitr)
library(doParallel)
library(foreach)
library(githubr)
#cl = makeCluster(detectCores()-2)
cl = makeCluster(14)
registerDoParallel(cl)
options(xtable.type="html")
setwd('~/AD_TargetRank/code/')
# Source modified utility functions from limma and sva package
source('../utilityFunctions/parallelDuplicateCorrelation.R')
source('../utilityFunctions/irwsva.build.R')
source('../utilityFunctions/f.pvalue.R')
knitr::opts_chunk$set(
  echo=FALSE,
  warning=FALSE,
  message=FALSE,
  error = FALSE,
  tidy = FALSE,
  cache = TRUE)
```

### Data download
Obtain count matrix and metadata from synapse
```{r download.data}
# Get reprocessed sample counts for temporal cortex
COUNT_ID <- 'syn10507730';
ALL_USED_IDs <- COUNT_ID
COUNT <- syn_temp$get(COUNT_ID)$path %>%
  read.table(header=T, sep='\t', check.names = F, row.names = 1)

Feature_Name_Sink <- row.names(COUNT)
row.names(COUNT) <- do.call( rbind, strsplit(row.names(COUNT),split='\\|' ) )[,1]

COUNT <- COUNT[ rowSums(COUNT[,] > 0) / (ncol(COUNT)) >= 0.05, ]
# Convert rownames of counts from tracking id to ensemble gene id
tmp = data.frame(Gene.ID = rownames(COUNT)) %>%
  dplyr::mutate(ID = Gene.ID) %>%
  tidyr::separate(ID, c('ensembl_gene_id', 'position'), sep = '\\.')
rownames(tmp) = tmp$Gene.ID
rownames(COUNT) = tmp[rownames(COUNT), 'ensembl_gene_id']
# Get sample ids
SampleID = data.frame(SampleID = colnames(COUNT),
                      ID = colnames(COUNT)) %>% 
  tidyr::separate(ID, c('A','B','ID'), sep = '_') %>%
  dplyr::select(SampleID, ID) %>%
  dplyr::mutate(ID = as.numeric(ID))
# Get technical metadata
METADATA_TECH_ID <- 'syn6100548'
ALL_USED_IDs[length(ALL_USED_IDs)+1] = METADATA_TECH_ID
METADATA_TECH <- syn_temp$get(METADATA_TECH_ID, version = 7)$path %>%
  read.table(sep=',',header=T, row.names=1) %>%
  group_by(sampleIdentifier) %>%
  top_n(1, -rRNA.rate) %>%
  dplyr::select(sampleIdentifier, BrodmannArea, barcode, individualIdentifier, batch, RIN) %>%
  unique %>%
  ddply(.(barcode), .fun = function(x){
    x = dplyr::mutate(x, batch = paste(batch, collapse = ''), RIN = sum(RIN, na.rm = T))  
  }) 
# Get 90+ age
METADATA_AGE_ID = 'syn10156693'
ALL_USED_IDs[length(ALL_USED_IDs)+1] = METADATA_AGE_ID
METADATA_AGE <- syn_temp$get(METADATA_AGE_ID, version = 3)$path %>%
  read.table(sep='\t', header=T)
# Get clinical metadata
METADATA_CLINICAL_ID <- 'syn6101474'
ALL_USED_IDs[length(ALL_USED_IDs)+1] = METADATA_CLINICAL_ID
METADATA_CLINICAL <- syn_temp$get(METADATA_CLINICAL_ID)$path %>%
  read.csv(header = T)
# Get picard metrics from synapse
METADATA.PICARD_ID <- 'syn8698270';#'syn20963391';
ALL_USED_IDs[length(ALL_USED_IDs)+1] = METADATA.PICARD_ID
METADATA.PICARD <- syn_temp$get(METADATA.PICARD_ID)$path %>%
  read.table(sep='\t', header=T, stringsAsFactors=F) %>% 
  dplyr::rename(sampleIdentifier = sample)

#REplace Syn IDs
#row.names(METADATA.PICARD_Old) <- as.character( Translator[ METADATA.PICARD_Old$sampleIdentifier , ][,2] )
row.names(METADATA.PICARD) <- METADATA.PICARD$sampleIdentifier 
row.names(METADATA_CLINICAL) <- METADATA_CLINICAL$individualIdentifier
#METADATA_CLINICAL <- METADATA_CLINICAL[ , colnames(METADATA_CLINICAL) != 'individualIdentifier']

###Left Here:
colnames(METADATA_CLINICAL)[ colnames(METADATA_CLINICAL) == 'individualID'] <- 'individualIdentifier'
colnames(METADATA_CLINICAL)[ colnames(METADATA_CLINICAL) == 'ageDeath'] <- 'AOD'
row.names(METADATA_TECH) <- METADATA_TECH$sampleIdentifier
METADATA <- dplyr::full_join(METADATA_TECH, METADATA_CLINICAL) %>%
  dplyr::inner_join(METADATA.PICARD ) %>%
  dplyr::select(-AOD) %>%
  dplyr::left_join(METADATA_AGE)
colnames(METADATA) = gsub('AlignmentSummaryMetrics__','',colnames(METADATA))
colnames(METADATA) = gsub('RnaSeqMetrics__','',colnames(METADATA))

#Get Transcript parameters...
#gene_id <- 'ensembl_transcript_id'
#filters <- 'ensembl_transcript_id'
#host <- 'ensembl.org'
#organism <- 'hsa'

# Parse gene IDs to use in query
#gene_ids <- row.names(COUNT)
#gene_ids <- do.call( rbind, strsplit( gene_ids, "[.]"))[,1]
#attrs <- c(filters, "ensembl_exon_id", "chromosome_name", "exon_chrom_start", "exon_chrom_end")

#ensembl <- biomaRt::useMart("ENSEMBL_MART_ENSEMBL", host = host)
  
#ds <- biomaRt::listDatasets(ensembl)[, "dataset"]
#ds <- grep(paste0("^", organism), ds, value = TRUE)
#  if (length(ds) == 0) {
#    stop(paste("Mart not found for:", organism))
#  } else if (length(ds) > 1) {
#    message("Found several marts")
#    sapply(ds, function(d) message(paste(which(ds == d), d, sep = ": ")))
#    n <- readline(paste0("Choose mart (1-", length(ds), ") : "))
#    ds <- ds[as.integer(n)]
#  }
#  ensembl <- biomaRt::useDataset(ds, mart = ensembl)
  
#coords <- biomaRt::getBM(filters = filters,
#                             attributes = attrs,
#                             values = gene_ids,
#                             mart = ensembl,
#                             useCache = FALSE)

#length <- plyr::ldply( names(coords), function(x) c( x , sum(IRanges::width(coords[[x]]))), .id = c("ensembl_gene_id","length") )  %>% 
#      dplyr::rename( gene=.data$V1 ) %>% 
#      dplyr::rename( length=.data$V2 )
#lsink<-length
#gc_content <- biomaRt::getBM(filters = filters,
#                                 attributes = c(filters, "hgnc_symbol", "percentage_gene_gc_content","gene_biotype", "chromosome_name"),
#                                 values = gene_ids,
#                                 mart = ensembl,
#                                 useCache = FALSE)
#colnames(length)[1] <- 'ensembl_transcript_id'
#biomart_results <- dplyr::full_join(gc_content, length)
#sink<-biomart_results

biomart_results <- read.table(syn_temp$get('syn22087693')$path, header=T, sep='\t', stringsAsFactors = F)

# Duplicate Ensembl Ids are collapsed into a single entry
collapse_duplicate_trans <- function(biomart_results){
  biomart_results %>%
    dplyr::group_by(.data$ensembl_transcript_id) %>%
    dplyr::mutate(hgnc_symbol = paste(.data$hgnc_symbol, collapse = ", ")) %>%
    unique()
}
biomart_results <- as.data.frame( collapse_duplicate_trans(biomart_results), stringsAsFactors = F )
row.names(biomart_results) <- biomart_results$ensembl_transcript_id
biomart_results <- biomart_results[ row.names(COUNT), ]
# Biomart IDs as rownames
#biomart_results <- tibble::column_to_rownames(biomart_results, var = 'ensembl_transcript_id')
#biomart_results <-  as.data.frame(biomart_results)
#biomart_results <- read.table('MSBB_biomart_results.tsv', sep='\t', header =T)
#write.table(biomart_results, file='MSBB_biomart_results.tsv', col.names =T, row.names=F, sep='\t', quote=F)

GENE.PARAM = biomart_results
GENE.GC = dplyr::select(GENE.PARAM, ensembl_transcript_id, percentage_gene_gc_content) %>% unique()
colnames(GENE.GC) = c('ensembl_gene_id', 'percentage_gc_content')

GENE.LEN = dplyr::select(GENE.PARAM, ensembl_transcript_id, length) %>% unique()
colnames(GENE.LEN) = c('ensembl_gene_id', 'gene.length')

```

### Data preprocessing
```{r preprocess.data,cache=FALSE, echo=FALSE}
# Choose samples with rRNA rate less than 5% and more PF_READS_ALIGNED
colnames(METADATA)[ colnames(METADATA) %in% 'pmi' ] <- 'PMI'
colnames(METADATA)[ colnames(METADATA) %in% 'Braak' ] <- 'bbscore'
colnames(METADATA)[ colnames(METADATA) %in% 'race' ] <- 'RACE'
colnames(METADATA)[ colnames(METADATA) %in% 'CERAD' ] <- 'NP.1'

#colnames(METADATA)[ colnames(METADATA) %in% '' ] <- ''

METADATA = as_tibble(METADATA, .name_repair = "unique") %>%
  plyr::ddply(.(barcode), .fun = function(x){
    x %>%
      dplyr::filter(PCT_RIBOSOMAL_BASES < 0.05) %>%
      dplyr::top_n(1, PF_READS_ALIGNED)
  }) %>%
  dplyr::filter(!is.na(BrodmannArea), 
                !is.na(CDR), 
                !is.na(PMI), 
                !is.na(RIN),
                !is.na(bbscore),
                !is.na(NP.1),
                !is.na(sampleIdentifier),
                RIN >= 5,
                BrodmannArea %in% c('BM10', 'BM22', 'BM36', 'BM44'))
# Fix metadata
ST <- c('M', 'F')
names(ST) <- c('male', 'female')

METADATA$sex <- as.character( ST[as.character(METADATA$sex)] )
METADATA = METADATA %>%
  dplyr::rename(Sex = sex) %>%
  dplyr::mutate(AOD = gsub('\\+','',AOD),
                Tissue = factor(BrodmannArea,
                                     levels = c('BM10', 'BM22', 'BM36', 'BM44'),
                                     labels = c('BM10' = 'FP', 'BM22' = 'STG', 
                                                'BM36' = 'PHG', 'BM44' = 'IFG')), 
                RIN2 = RIN^2, 
                Sex = factor(Sex, levels = c('M','F'), labels = c('MALE', 'FEMALE')),
                Tissue1 = Tissue)
rownames(METADATA) = METADATA$sampleIdentifier
# Get harmonised case control definition
METADATA$Diagnosis = 'OTHER'
METADATA$Diagnosis[METADATA$CDR <= 0.5 & METADATA$bbscore <= 3 & METADATA$NP.1 <= 1] = 'CONTROL'
METADATA$Diagnosis[METADATA$CDR >= 1 & METADATA$bbscore >= 4 & METADATA$NP.1 >= 2] = 'AD'
METADATA$Tissue.Diagnosis = paste(METADATA$Tissue, METADATA$Diagnosis, sep = '.')
# Fix missing batch
levels(METADATA$batch)[levels(METADATA$batch) == ''] = 'NoBatch'
# Introduce ApoE4
METADATA$APOE4 = 0

METADATA$Apo1 <- do.call( rbind, strsplit( as.character(METADATA$apoeGenotype), "" ))[,1] 
METADATA$Apo2 <- do.call( rbind, strsplit( as.character(METADATA$apoeGenotype), "" ))[,2] 

METADATA$APOE4[METADATA$Apo1 == 4 | METADATA$Apo2 == 4] = 1
METADATA$APOE4[METADATA$Apo1 == 4 & METADATA$Apo2 == 4] = 2
METADATA$Tissue.APOE4 = paste(METADATA$Tissue, METADATA$APOE4, sep = '.')
# Match covariates to expression data
indToRetain = intersect(METADATA$sampleIdentifier, colnames(COUNT))
indRemoved = setdiff(colnames(COUNT), METADATA$sampleIdentifier)
COUNT <- COUNT[, indToRetain]
METADATA = as.data.frame(METADATA)
rownames(METADATA) = METADATA$sampleIdentifier
METADATA = METADATA[indToRetain,]
```
`r dim(COUNT)[2]` samples from `r length(unique(METADATA$individualIdentifier))` subjects were obtained from the MSSM cohorts in AMP-AD reprocessed rnaseq project. 

Following `r length(indRemoved)` samples were removed: `r indRemoved`

### Covariate clustering
Determine relationship between covariates
```{r covariates.clustering}
primaryVariable <- c("CDR", "Tissue.Diagnosis", "Tissue.APOE4")
#_# ADD DIAGNOSIS HERE TO REGRESS FOR TWAS
FactorCovariates <- c("individualIdentifier", "batch", "RACE", "Sex", "Tissue.Diagnosis", "Tissue.APOE4")
ContCovariates <- c("CDR", "RIN", "RIN2", "AOD","PMI",  "PCT_PF_READS_ALIGNED", "PCT_CODING_BASES",
                    "PCT_INTERGENIC_BASES", "PCT_INTRONIC_BASES", "PCT_RIBOSOMAL_BASES")
METADATA$Diagnosis <- as.factor(METADATA$Diagnosis)
# Find inter relation between factor covariates
COVARIATES = METADATA[,c(FactorCovariates,ContCovariates),drop=F]
rownames(COVARIATES) <- METADATA$sampleIdentifier
# Convert factor covariates to factors
COVARIATES[,FactorCovariates] = lapply(COVARIATES[,FactorCovariates], factor)
COVARIATES[,ContCovariates] = lapply(COVARIATES[,ContCovariates], as.character)
COVARIATES[,ContCovariates] = lapply(COVARIATES[,ContCovariates], as.numeric)
```
Correlation/association between covariates at an FDR <= 0.1
```{r covariates.correlation, cache=FALSE, fig.width=10, fig.height=6}
COVARIATES.CORRELATION = getAssociationStatistics(COVARIATES, PVAL = 0.05)
draw(COVARIATES.CORRELATION$plot, heatmap_legend_side = 'left', padding  = unit(c(18,2,2,18), 'mm'))
```
### Explore metadata
```{r data.explore, cache=FALSE, fig.width = 12, fig.height = 8}
my.theme = theme(legend.position = 'top', axis.text.x = element_text(angle = 90, hjust = 1))
# RIN
p = list()
p[[1]] = ggplot(COVARIATES, aes(x = Tissue.Diagnosis, y = RIN)) + geom_boxplot()
p[[1]] = p[[1]] + ggtitle('RIN') + my.theme
# Age Of Death
p[[2]] = ggplot(COVARIATES, aes(x = Tissue.Diagnosis, y = as.numeric(AOD))) + geom_boxplot()
p[[2]] = p[[2]] + ggtitle('AOD') + my.theme
# PMI
p[[3]] = ggplot(COVARIATES, aes(x = Tissue.Diagnosis, y = as.numeric(PMI))) + geom_boxplot()
p[[3]] = p[[3]] + ggtitle('PMI') + my.theme
# Ribosomal bases
p[[4]] = ggplot(COVARIATES, aes(x = Tissue.Diagnosis, y = as.numeric(PCT_RIBOSOMAL_BASES))) + geom_boxplot()
p[[4]] = p[[4]] + ggtitle('Fraction of Ribosomal Bases') + my.theme
# Intronic bases
p[[5]] = ggplot(COVARIATES, aes(x = Tissue.Diagnosis, y = as.numeric(PCT_INTRONIC_BASES))) + geom_boxplot()
p[[5]] = p[[5]] + ggtitle('Fraction Intronic Bases') + my.theme
# Intergenic bases
p[[6]] = ggplot(COVARIATES, aes(x = Tissue.Diagnosis, y = as.numeric(PCT_INTERGENIC_BASES))) + geom_boxplot()
p[[6]] = p[[6]] + ggtitle('Fraction Intergenic Bases') + my.theme
multiplot(plotlist = p, cols = 3)
```

### Filter genes
* Remove genes that have less than 1 cpm counts in at least 50% of samples per Tissue x Diagnosis
* Remove genes with missing gene length and percentage GC content
```{r cpmnormalisation}

####Need to conserve computation space: filter for protien coding
COUNT <- COUNT[ row.names(COUNT) %in% biomart_results[ biomart_results$gene_biotype=='protein_coding',]$ensembl_transcript_id, ]

row.names(COUNT) <- do.call(rbind, strsplit( row.names(COUNT), "[.]") )[,1]
genesToAnalyze = COVARIATES %>%
  rownameToFirstColumn('SampleID') %>%
  dlply(.(Tissue.Diagnosis), .fun = function(mtd, count){
    processed.counts = getGeneFilteredGeneExprMatrix(count[,mtd$SampleID],
                                                     MIN_GENE_CPM=1, 
                                                     MIN_SAMPLE_PERCENT_WITH_MIN_GENE_CPM=0.5)
    processed.counts$filteredExprMatrix$genes
  }, COUNT)
genesToAnalyze = unlist(genesToAnalyze) %>% 
  unique() %>%
  intersect(GENE.GC$ensembl_gene_id[!is.na(GENE.GC$percentage_gc_content)]) %>%
  intersect(GENE.LEN$ensembl_gene_id[!is.na(GENE.LEN$gene.length)]) %>%
  setdiff(c("N_unmapped", "N_multimapping", "N_noFeature", "N_ambiguous"))
PROCESSED_COUNTS = getGeneFilteredGeneExprMatrix(COUNT[genesToAnalyze, ], 
                                                 MIN_GENE_CPM=0, 
                                                 MIN_SAMPLE_PERCENT_WITH_MIN_GENE_CPM=0)
# Check gene biotype
## Define biomart object
#mart <- useMart(biomart = "ENSEMBL_MART_ENSEMBL", host = "jul2019.archive.ensembl.org", dataset = "hsapiens_gene_ensembl")
## Query biomart
#Ensemble2HGNC <- getBM(attributes = c("ensembl_gene_id", "hgnc_symbol", "gene_biotype"),
                       #filters = "ensembl_gene_id", 
                       #values = PROCESSED_COUNTS$filteredExprMatrix$genes,
                       #mart = mart)
Ensemble2HGNC <- biomart_results[ biomart_results$ensembl_transcript_id %in% row.names(PROCESSED_COUNTS$filteredExprMatrix$genes), ]

summary(factor(Ensemble2HGNC$gene_biotype)) %>%
  rownameToFirstColumn('Biotype') %>%
  dplyr::rename(fraction = DF) %>%
  dplyr::mutate(fraction = fraction/dim(PROCESSED_COUNTS$filteredExprMatrix$genes)[1]) %>%
  dplyr::filter(fraction >= 0.01) %>%
  kable
```

### Library Normalisation
Library normalisation is performed using cqn (conditional quantile normalisation)
```{r cqn}
GENE.GC <- as.data.frame(GENE.GC[complete.cases(GENE.GC),] )
row.names(GENE.GC) <- GENE.GC$ensembl_gene_id
GENE.LEN <-as.data.frame(GENE.LEN[complete.cases(GENE.LEN),])
row.names(GENE.LEN) <- GENE.LEN$ensembl_gene_id
GENE.LEN$gene.length <- as.numeric(GENE.LEN$gene.length)
# Compute offset for gene length and gc content
CQN.GENE_EXPRESSION = cqn(PROCESSED_COUNTS$filteredExprMatrix$counts, 
                          x = GENE.GC[PROCESSED_COUNTS$filteredExprMatrix$genes$genes, 'percentage_gc_content'],
                          lengths = GENE.LEN[PROCESSED_COUNTS$filteredExprMatrix$genes$genes, 'gene.length'],
                          lengthMethod = "smooth", 
                          verbose = FALSE)
CQN.GENE_EXPRESSION$E = CQN.GENE_EXPRESSION$y + CQN.GENE_EXPRESSION$offset
```

### Outlier Analysis
#### Sample outliers
Outlier analysis is performed before library normalisation with raw cpm counts
```{r outlier.analysis, cache = FALSE, fig.width = 10}
indToRemove = c('hB_RNA_10622')
# Find principal components of expression to plot
PC <- prcomp(CQN.GENE_EXPRESSION$E, scale.=T, center = T)
# Plot first 2 PCs
plotdata <- data.frame(SampleID=rownames(PC$rotation), 
                       PC1=PC$rotation[,1], 
                       PC2=PC$rotation[,2])
plotdata <- left_join(plotdata, rownameToFirstColumn(COVARIATES, 'SampleID')) %>%
  dplyr::mutate(label = SampleID) %>%
  tidyr::separate(Tissue.Diagnosis, c('Tissue', 'Diagnosis'), sep = '\\.')
plotdata$label[!(plotdata$SampleID %in% indToRemove)] = ''
p <- ggplot(plotdata, aes(x=PC1, y=PC2))
p <- p + geom_point(aes(color=Diagnosis, size=RIN, shape = Sex))
p <- p + theme_bw() + theme(legend.position="right")
p <- p + geom_text(aes(label= label), size=4, hjust=0)
p
# Plot abberent distribution of logcpm counts
tmp1 = CQN.GENE_EXPRESSION$E %>%
  rownameToFirstColumn('Gene.ID') %>%
  tidyr::gather(SampleID, logCPM, -Gene.ID) %>%
  left_join(COVARIATES %>%
              rownameToFirstColumn('SampleID')) %>%
  tidyr::separate(Tissue.Diagnosis, c('Tissue', 'Diagnosis'), sep = '\\.')
p = ggplot(tmp1 %>%
             dplyr::filter(SampleID %in% indToRemove),
           aes(x = logCPM, color = SampleID)) + geom_density() 
p = p + theme(legend.position = 'top') + facet_grid(Diagnosis+.~Tissue)
p
indToRetain = setdiff(colnames(PROCESSED_COUNTS$filteredExprMatrix$counts), indToRemove)
PROCESSED_COUNTS$filteredExprMatrix$counts = PROCESSED_COUNTS$filteredExprMatrix$counts[,indToRetain]
CQN.GENE_EXPRESSION$E = CQN.GENE_EXPRESSION$E[,indToRetain]
COVARIATES = COVARIATES[indToRetain,]
tmp = COVARIATES %>%
  tidyr::separate(Tissue.Diagnosis, c('Tissue', 'Diagnosis'), sep = '\\.') %>%
  group_by(Tissue, Diagnosis) %>%
  summarise(count = n()) %>%
  spread(Diagnosis, count)
```
Processing `r dim(PROCESSED_COUNTS$filteredExprMatrix)[1]` genes in `r dim(PROCESSED_COUNTS$filteredExprMatrix)[2]` samples

Based on the expression pattern following samples were tagged as outliers: `r paste(indToRemove, collapse = ', ')`

Distribution of samples are: `r kable(tmp)`

#### Gene outliers
Assign NA values to genes that are above and below 3 std deviation of its distribution
```{r winsorise.data}
# Set gene counts in specific samples that are deviating 3 sd from other samples to 3SD limit
LOG.CPM = apply(CQN.GENE_EXPRESSION$E, 1, function(x){
  mn = mean(x, na.rm = T)
  std.dev = sd(x, na.rm = T)
  
  x[x < (mn-3*std.dev)] = NA
  x[x > (mn+3*std.dev)] = NA
  return(x)
}) %>% t
CQN.GENE_EXPRESSION$E = LOG.CPM
CQN.GENE_EXPRESSION$E.no.na = CQN.GENE_EXPRESSION$E
CQN.GENE_EXPRESSION$E.no.na[is.na(CQN.GENE_EXPRESSION$E.no.na)] = 0
LIB.SIZE = colSums(PROCESSED_COUNTS$filteredExprMatrix$counts)
NEW.COUNTS = (2^LOG.CPM) * t(replicate(dim(LOG.CPM)[1], LIB.SIZE))/1e6
```
### Sample clustering
PCA based clustering of samples
```{r decompse.normalise.data1.1, cache=FALSE, fig.height=5, fig.width=10, results='asis'}
# Find principal components of expression to plot
PC <- prcomp(CQN.GENE_EXPRESSION$E.no.na, scale.=T, center = T)
# Plot first 2 PCs
plotdata <- data.frame(SampleID=rownames(PC$rotation), 
                       PC1=PC$rotation[,1], 
                       PC2=PC$rotation[,2])
plotdata <- left_join(plotdata, rownameToFirstColumn(COVARIATES, 'SampleID')) %>%
  tidyr::separate(Tissue.Diagnosis, c('Region','Diagnosis'), sep = '\\.') %>% 
  dplyr::mutate(Region = factor(Region), batch = factor(batch))
p <- ggplot(plotdata, aes(x=PC1, y=PC2))
p <- p + geom_point(aes(color=Diagnosis, size=RIN, shape = Sex))
p <- p + theme_bw() + theme(legend.position="right") + facet_grid(.~Region, scales = 'free_y')
p
```
Tree based classification of samples
```{r decompse.normalise.data1.2, cache=FALSE, fig.height=6, fig.width=10, results='asis'}
# Eucledian tree based analysis
COVARIATES.tmp = (COVARIATES[,c(FactorCovariates), drop = F])
COVARIATES.tmp[is.na(COVARIATES.tmp)] = 0
tree = hclust(as.dist(t(CQN.GENE_EXPRESSION$E.no.na)))
cols = WGCNA::labels2colors(COVARIATES.tmp);
WGCNA::plotDendroAndColors(tree, 
                           colors = cols, 
                           dendroLabels = FALSE, 
                           abHeight = 0.80, 
                           main = "Sample dendrogram",
                           groupLabels = colnames(COVARIATES.tmp))
```
Coexpression of genes 
```{r coexp1, cache=FALSE, fig.height=5, fig.width=5}
#cr = cor(t(CQN.GENE_EXPRESSION$E.no.na))
#hist(cr, main = 'Distribution of correlation between genes', xlab = 'Correlation')
```

### Significant Covariates
Correlation between pca of unadjusted mRNA expression and covariates are used to find significant covariates
```{r preadj.covariates}
# Find correlation between PC's of gene expression with covariates
preAdjustedSigCovars = runPCAandPlotCorrelations(CQN.GENE_EXPRESSION$E.no.na, 
                                                 COVARIATES,
                                                 'NULL design(voom-normalized)', 
                                                 isKeyPlot=TRUE, 
                                                 MIN_PVE_PCT_PC = 1)
```

Significant covariates to adjust at FDR 0.1 are `r preAdjustedSigCovars$significantCovars`
```{r preadj.covariates.plot, cache=FALSE, fig.width=12, fig.height=8}
preAdjustedSigCovars[["PC_res"]][[2]]$plotData
```

### Normalisation (iterative design)
Since many covariates are correlated, re-normalising and re-adjusting COUNTS with an iterative design matrix.

NOTE:
1. Using a mixed effect model where random effect is chosen as individualIdentifier
2. Adding batch and Sex a priori to variable selection
3. Primary variable of interest Tissue.Diagnosis is excluded from the pool of available covariates for selection
```{r iterative.norm, results='asis', warning = FALSE}
# Primary variable of interest
postAdjustCovars = c('batch', 'Sex');
# Assign residual covariates
residualCovars = setdiff(preAdjustedSigCovars$significantCovars, 
                         c(postAdjustCovars, primaryVariable, 'individualIdentifier'))
residualSigCovars = preAdjustedSigCovars
covariatesEffects = preAdjustedSigCovars$Effects.significantCovars[residualCovars]
postAdjustCovars = c(postAdjustCovars, names(which.max(covariatesEffects))) %>% unique()
loopCount = 0 
notEstimable <- NULL
Start <- Sys.time()
foo <- 0
while(length(residualSigCovars$significantCovars)!=0 && loopCount <= 20){ #_# <= 8
  writeLines(paste('Using following covariates in the model:',
                   paste(postAdjustCovars, collapse=', '),
                   'as fixed effects and individualIdentifier as random effect'))
  
  # Post adjusted design matrix
  DM1 = getDesignMatrix(COVARIATES[,postAdjustCovars,drop=F],Intercept = F)
  DM1$design = DM1$design[,linColumnFinder(DM1$design)$indepCols]
  
  # Estimate voom weights for dispersion control
  cnts = NEW.COUNTS
  cnts[is.na(cnts)] = 0
  VOOM.GENE_EXPRESSION = voom(cnts, design=DM1$design, 
                              plot=F)#, na.rm = T)
  
  # Calculate correlation values of random effects
  correlation = parallelDuplicateCorrelation(VOOM.GENE_EXPRESSION,
                                             block = COVARIATES$individualIdentifier,
                                             method = 'lmer')
  # correlation = list(); correlation$cor = 0.3819258
  
  # Re-estimate voom weights
  if (!is.nan(correlation$cor)){
    # Re-estimate voom weights
    VOOM.GENE_EXPRESSION = voom(cnts, 
                                design=DM1$design, plot=F, 
                                block = COVARIATES$individualIdentifier, 
                                correlation = correlation$cor)
    
    # Fit linear model using new weights and new design
    VOOM.ADJUSTED.FIT = lmFit(CQN.GENE_EXPRESSION$E,
                              design = DM1$design,
                              weights = VOOM.GENE_EXPRESSION$weights,
                              block = COVARIATES$individualIdentifier, 
                              correlation = correlation$cor)
    
    # Residuals after normalisation
    RESIDUAL.GENE_EXPRESSION = residuals.MArrayLM(VOOM.ADJUSTED.FIT,
                                                  CQN.GENE_EXPRESSION$E)
  }else {
    notEstimable = c(notEstimable, postAdjustCovars[length(postAdjustCovars)])
    postAdjustCovars = postAdjustCovars[1:(length(postAdjustCovars)-1)]
  }
  
  # Residual covariates to choose from
  residCovars <- setdiff(c(FactorCovariates,ContCovariates),
                         c(postAdjustCovars, primaryVariable, 'individualIdentifier'))
  
  # Find PC of residual gene expression and significant covariates that are highly correlated with PCs
  expr = RESIDUAL.GENE_EXPRESSION; expr[is.na(expr)] = 0; expr = expr[rowSums(expr)!=0,]
  residualSigCovars = runPCAandPlotCorrelations(expr, 
                                                COVARIATES[, residCovars, drop=F], 
                                                'adjusted design(voom-normalized)',
                                                isKeyPlot=TRUE)
  
  # Add postadjusted covariates (if any)
  covariatesEffects = residualSigCovars$Effects.significantCovars[residCovars]
  
  postAdjustCovars = c(postAdjustCovars, names(which.max(covariatesEffects)))
  loopCount = loopCount + 1
  # print(loopCount)
}
modelStr <- paste(paste(gsub('_','\\\\_',postAdjustCovars), collapse=', '),
                  'as fixed effects')
tmp <- paste('Using following covariates in the final model:', modelStr)
```
`r tmp`

### Sanity check
```{r residual.adj, cache=FALSE, fig.width=12, fig.height=8}
# Find PC of residual gene expression and significant covariates that are highly correlated with PCs
residualSigCovars = runPCAandPlotCorrelations(expr, 
                                              COVARIATES,
                                              'adjusted design(voom-normalized)',
                                              isKeyPlot=TRUE)
residualSigCovars[["PC_res"]][[2]]$plotData
```
Coexpression of genes 
```{r coexp2, cache=FALSE, fig.height=5, fig.width=5}
#cr = cor(t(expr))
#hist(cr, main = 'Distribution of correlation between genes', xlab = 'Correlation')
```
PCA of residual data
```{r decompse.normalise.data2.1, cache=FALSE, fig.height=6, fig.width=10, results='asis'}
# Find principal components of expression to plot
PC <- prcomp(expr, scale.=T, center = T)
# Plot first 2 PCs
plotdata <- data.frame(SampleID=rownames(PC$rotation), 
                       PC1=PC$rotation[,1], 
                       PC2=PC$rotation[,2])
plotdata <- left_join(plotdata, rownameToFirstColumn(COVARIATES, 'SampleID')) %>%
  tidyr::separate(Tissue.Diagnosis, c('Region','Diagnosis'), sep = '\\.') %>% 
  dplyr::mutate(Region = factor(Region))
p <- ggplot(plotdata, aes(x=PC1, y=PC2))
p <- p + geom_point(aes(color=Diagnosis, size=RIN, shape = Sex))
p <- p + theme_bw() + theme(legend.position="right") + facet_grid(.~Region, scales = 'free_y')
p
```
Tree based clustering of residual data
```{r decompse.normalise.data2.2, cache=FALSE, fig.height=8, fig.width=12, results='asis'}
# Eucledian tree based analysis
COVARIATES.tmp = data.matrix(COVARIATES[,FactorCovariates])
COVARIATES.tmp[is.na(COVARIATES.tmp)] = 0
tree = hclust(as.dist(t(expr)))
cols = WGCNA::labels2colors(COVARIATES.tmp);
WGCNA::plotDendroAndColors(tree, 
                           colors = cols, 
                           dendroLabels = FALSE, 
                           abHeight = 0.80, 
                           main = "Sample dendrogram",
                           groupLabels = colnames(COVARIATES.tmp))
#save.image('MSBB_Image.RData')
```

### Adjust data with covariates for Network Analysis
Identified covariates are regressed out from the expression matrix for network analysis
```{r network.adjust}
# Get design matrix
DESIGN.NET = getDesignMatrix(COVARIATES[, postAdjustCovars, drop = F], Intercept = F)
DESIGN.NET = DESIGN.NET$design[,linColumnFinder(DESIGN.NET$design)$indepCols]
# Re-estimate voom weights
VOOM.NET.WEIGHTS = voom(cnts, 
                        design = DESIGN.NET, plot=F,
                        block = COVARIATES$individualIdentifier, 
                        correlation = correlation$cor)
# Fit linear model using new weights and new design
VOOM.NET.WEIGHTS$E = CQN.GENE_EXPRESSION$E
VOOM.NET.FIT = lmFit(VOOM.NET.WEIGHTS)
# Residuals after normalisation
RESIDUAL.NET.GENE_EXPRESSION = residuals.MArrayLM(VOOM.NET.FIT,
                                                  CQN.GENE_EXPRESSION$E)
```

### SVA Adjustments for eQTL analysis
Conditioned on primary variable (Tissue.Diagnosis) and identified covariates estimate surrogate variables using SVA package
```{r sva.adjust, cache=FALSE}
# Get design matrix
DESIGN = getDesignMatrix(COVARIATES[, c(primaryVariable[2], postAdjustCovars), drop = F], Intercept = F)
DESIGN$design = DESIGN$design[,linColumnFinder(DESIGN$design)$indepCols]
# Get (null) design matrix
MODEL0 = DESIGN$design[,-grep(primaryVariable[2],colnames(DESIGN$design))] # Get null model by removing variable of interest
MODEL0 = MODEL0[,linColumnFinder(MODEL0)$indepCols]
MODEL1 = DESIGN$design
MODEL1 = MODEL1[,linColumnFinder(MODEL1)$indepCols]
# Re-estimate voom weights
VOOM.WEIGHTS = voom(cnts, 
                    design = MODEL1, plot=F,
                    block = COVARIATES$individualIdentifier, 
                    correlation = correlation$cor)
# Fit linear model using new weights and new design
VOOM.WEIGHTS$E = CQN.GENE_EXPRESSION$E
FIT = lmFit(VOOM.WEIGHTS)
# Get residuals from differential expression model
RESIDUAL.SVA.GENE_EXPRESSION = residuals.MArrayLM(FIT, CQN.GENE_EXPRESSION$E)
# Compute actual variance of all principal components
expr = RESIDUAL.SVA.GENE_EXPRESSION;
expr[is.na(expr)] = 0
tmp = svd(expr)
actual.var = tmp$d^2/sum(tmp$d^2)
# Compute permuted variance of all principal components
permuted.var = foreach(i = 1:20, .combine = rbind) %dopar% {
  tmp.residual = t(apply(expr, 1, sample, replace = FALSE))
  tmp = svd(tmp.residual)
  permuted.var = tmp$d^2/sum(tmp$d^2)
}
permuted.var = apply(permuted.var, 2, mean)
NUM.SV = sum(actual.var >= permuted.var[1])
# Plot variance components
var.comp = data.frame(component = 1:length(actual.var), 
                      residual = actual.var, 
                      permuted.residual = permuted.var) %>%
  tidyr::gather(data, value, -component)
p = ggplot(var.comp %>% filter(component <= round(NUM.SV*1.2)), aes(x = component, y = value, color = data)) + geom_point()
p = p + geom_hline(yintercept=permuted.var[1], linetype = 'dashed') + xlab('Singular Dimension Index')
p = p + geom_vline(xintercept=NUM.SV, linetype = 'dashed') + ylab('Fraction of Variance Explained')
p = p + theme(legend.position = c(0.8, 0.8), legend.title = element_blank())
p
# Estimate surrogate variables
##JKG Add in in case lack of valuse adds singularity issue
#if( length(table(MODEL0[,'PCT_RIBOSOMAL_BASES'])) < .05*dim(MODEL0)[1] ){
#  MODEL0 <- MODEL0[,colnames(MODEL0)[colnames(MODEL0)!='PCT_RIBOSOMAL_BASES'] ]
#}else{}
#if( length(table(MODEL1[,'PCT_RIBOSOMAL_BASES'])) < .05*dim(MODEL1)[1] ){
#  MODEL1 <- MODEL1[,colnames(MODEL1)[colnames(MODEL1)!='PCT_RIBOSOMAL_BASES'] ]
#}else{}
SURR.VAR = sva::sva(CQN.GENE_EXPRESSION$E.no.na, MODEL1, MODEL0, n.sv = NUM.SV, B = 30)$sv
colnames(SURR.VAR) = paste0('SV',1:dim(SURR.VAR)[2])
rownames(SURR.VAR) = rownames(MODEL1)
# Re-estimate voom weights
VOOM.SVA.WEIGHTS = voom(cnts, 
                        design = cbind(MODEL1, SURR.VAR), plot=F,
                        block = COVARIATES$individualIdentifier, 
                        correlation = correlation$cor)
# Fit linear model using new weights and new design
VOOM.SVA.WEIGHTS$E = CQN.GENE_EXPRESSION$E
VOOM.SVA.FIT = lmFit(VOOM.SVA.WEIGHTS)
# Residuals after normalisation
RESIDUAL.SVA.GENE_EXPRESSION = residuals.MArrayLM(VOOM.SVA.FIT,
                                                  CQN.GENE_EXPRESSION$E)
# Add variable of interest back to the residuals
varsToAddIn = grep("Tissue.Diagnosis", colnames(MODEL1), value = T)
RESIDUAL.SVA.GENE_EXPRESSION = RESIDUAL.SVA.GENE_EXPRESSION + 
  VOOM.SVA.FIT$coefficients[,varsToAddIn] %*% t(VOOM.SVA.FIT$design[,varsToAddIn])
#save.image('MSBB_Image.RData')
```


### Differential expression analysis (with Tissue.CDR as primary variable)
Differential expression is performed on the primary variable by controlling for covariates identified above

Interpretation of Tissue.CDR
1. FP.CDR: change in CDR in frontal pole where 0 no cognitive decline and 5 severe cognitive decline
2. IFG.CDR: change in CDR in inferior frontal gyrus where 0 no cognitive decline and 5 severe cognitive decline
3. PHG.CDR: change in CDR in parahippocampal gyrus where 0 no cognitive decline and 5 severe cognitive decline
4. STG.CDR: change in CDR in superior temporal gyrus where 0 no cognitive decline and 5 severe cognitive decline

Genes that are differentially expressed at an FDR <= 0.05 are
```{r diff.exp, fig.height=6, fig.width=15}
# Get design matrix
COVARIATES.tmp = COVARIATES %>%
  tidyr::separate(Tissue.Diagnosis, c('Tissue', 'Diagnosis'), sep = '\\.') %>%
  dplyr::mutate(Tissue = factor(Tissue))
DESIGN = getDesignMatrix(COVARIATES.tmp[, c('Tissue', postAdjustCovars), drop = F], Intercept = F)
ind = grep('Tissue', colnames(DESIGN$design))
DESIGN$design[,ind] = DESIGN$design[,ind] * as.numeric(COVARIATES.tmp[,'CDR'])
colnames(DESIGN$design)[ind] = paste0( colnames(DESIGN$design)[ind],'.CDR')
DESIGN$design = DESIGN$design[,c(linColumnFinder(DESIGN$design)$indepCols)]
# Re-estimate voom weights
VOOM.WEIGHTS = voom(cnts,
                    design=DESIGN$design, plot=F,
                    block = COVARIATES$individualIdentifier, 
                    correlation = correlation$cor)
# Fit linear model using new weights and new design
VOOM.WEIGHTS$E = CQN.GENE_EXPRESSION$E
FIT = lmFit(VOOM.WEIGHTS)
# Fit contrast
contrast = makeContrasts(contrasts = c("TissueFP.CDR", 
                                       "TissueIFG.CDR", 
                                       "TissuePHG.CDR", 
                                       "TissueSTG.CDR"),
                         levels = colnames(FIT$coefficients))
FIT.CONTR = contrasts.fit(FIT, contrasts=contrast)
FIT.CONTR = eBayes(FIT.CONTR)
# Get differnetial expression
DE = lapply(1:dim(contrast)[2], function(i, FIT){
  topTable(FIT, coef=i, number = dim(FIT)[1], confint = T) %>%
    rownameToFirstColumn('ensembl_gene_id')
}, FIT.CONTR)
names(DE) = colnames(contrast)
#sink<-DE
#_# Reformat Gene Param for combination:
GENE.PARAM <- GENE.PARAM[ row.names(DE[[1]]) , ]
colnames(GENE.PARAM)[ colnames(GENE.PARAM) == 'ensembl_transcript_id' ] <- 'ensembl_gene_id'
  
DE = DE %>% 
  data.table::rbindlist(idcol = 'Comparison') %>%
  dplyr::mutate(Comparison = gsub('Tissue','',Comparison),
                Study = 'MSSM',
                Sex = 'ALL') %>%
  tidyr::separate(Comparison, c('Tissue', 'Comparison1'), sep = '\\.') %>%
  dplyr::rename(Comparison = Comparison1) %>%
  dplyr::left_join(GENE.PARAM %>%
                     dplyr::select(ensembl_gene_id, hgnc_symbol, percentage_gene_gc_content, length) %>%
                     unique())
DE$Direction = 'NONE'
DE$Direction[DE$adj.P.Val <= 0.05 & DE$logFC <= -log2(1.2)] = 'DOWN'
DE$Direction[DE$adj.P.Val <= 0.05 & DE$logFC >= log2(1.2)] = 'UP'
#tmp = DE %>%
#  dplyr::select(ensembl_gene_id, Comparison, Direction, Tissue) %>%
#  group_by(Tissue, Comparison, Direction) %>%
#  dplyr::summarise(FDR_0_05_FC_1.2 = length(unique(ensembl_gene_id))) %>%
#  spread(Direction, FDR_0_05_FC_1.2) 
#kable(tmp)
p = ggplot(DE, aes(y = -log10(adj.P.Val), x = logFC, color = Direction)) + geom_point() + xlim(c(-1,1))
p = p + scale_color_manual(values = c('green','grey','red')) + theme(legend.position = 'top')
p = p + facet_grid(Comparison+.~Tissue, scales = 'free')
p
all.diff.exp = list(SourceDiagnosis = DE)
all.fit = list(SourceDiagnosis = FIT)
#save.image('MSBB_Image.RData')
```

### Differential expression analysis (with Tissue.Diagnosis as primary variable)
Differential expression is performed on the primary variable by controlling for covariates identified above

Interpretation of Tissue.Diagnosis
1. FP.AD: Samples from frontal pole region with CDR >= 1 and bbscore >= 4 and NP.1 >= 2
2. FP.CONTROL: Samples from frontal pole region with CDR <= 0.5 and bbscore <= 3 and NP.1 <= 1
3. FP.OTHER: All the other frontal pole samples
4. PHG.AD: Samples from parahippocampal gyrus region with CDR >= 1 and bbscore >= 4 and NP.1 >= 2
5. PHG.CONTROL: Samples from parahippocampal gyrus region with CDR <= 0.5 and bbscore <= 3 and NP.1 <= 1
6. PHG.OTHER:All the other parahippocampal gyrus samples
7. STG.AD: Samples from frontal superior temporal gyrus with CDR >= 1 and bbscore >= 4 and NP.1 >= 2
8. STG.CONTROL: Samples from superior temporal gyrus region with CDR <= 0.5 and bbscore <= 3 and NP.1 <= 1
9. STG.OTHER: All the other superior temporal gyrus samples
10. IFG.AD: Samples from inferior frontal gyrus region with CDR >= 1 and bbscore >= 4 and NP.1 >= 2
11. IFG.CONTROL: Samples from inferior frontal gyrus region with CDR <= 0.5 and bbscore <= 3 and NP.1 <= 1
12. IFG.OTHER: All the other inferior frontal gyrus samples

Genes that are differentially expressed at an FDR <= 0.05 are
```{r diff.exp1, fig.height=15, fig.width=13}
# Get design matrix
DESIGN = getDesignMatrix(COVARIATES[, c(primaryVariable[2], postAdjustCovars), drop = F], Intercept = F)
DESIGN$design = DESIGN$design[,linColumnFinder(DESIGN$design)$indepCols]
# Re-estimate voom weights
VOOM.WEIGHTS = voom(cnts,
                    design=DESIGN$design, plot=F,
                    block = COVARIATES$individualIdentifier, 
                    correlation = correlation$cor)
# Fit linear model using new weights and new design
VOOM.WEIGHTS$E = CQN.GENE_EXPRESSION$E
FIT = lmFit(VOOM.WEIGHTS)
# Fit contrast
cntr = c()
for (region in c('FP', 'STG', 'PHG', 'IFG')){
  tmp = combn(paste0('Tissue.Diagnosis', region, '.', c('AD', 'OTHER', 'CONTROL')),2)
  cntr = c(cntr, apply(tmp, 2, paste, collapse = '-'))
}
contrast = makeContrasts(contrasts=cntr,
                         levels = colnames(FIT$coefficients))
FIT.CONTR = contrasts.fit(FIT, contrasts=contrast)
FIT.CONTR = eBayes(FIT.CONTR)
# Get differnetial expression
DE = lapply(1:dim(contrast)[2], function(i, FIT){
  topTable(FIT, coef=i, number = dim(FIT)[1], confint = T) %>%
    rownameToFirstColumn('ensembl_gene_id')
}, FIT.CONTR)
names(DE) = colnames(contrast)
DE = DE %>% 
  data.table::rbindlist(idcol = 'Comparison') %>%
  dplyr::mutate(Comparison = gsub('Tissue.Diagnosis','',Comparison),
                Study = 'MSSM',
                Sex = 'ALL') %>%
  tidyr::separate(Comparison, c('from.state','to.state'), sep = '-') %>%
  tidyr::separate(from.state, c('Tissue','reference'), sep = '\\.') %>%
  tidyr::separate(to.state, c('Tissue1','against'), sep = '\\.') %>%
  tidyr::unite(Comparison, reference, against, sep = '-') %>%
  dplyr::select(-Tissue1) %>%
  dplyr::left_join(GENE.PARAM %>%
                     dplyr::select(ensembl_gene_id, hgnc_symbol, percentage_gene_gc_content, length) %>%
                     unique())
DE$Direction = 'NONE'
DE$Direction[DE$adj.P.Val <= 0.05 & DE$logFC <= -log2(1.2)] = 'DOWN'
DE$Direction[DE$adj.P.Val <= 0.05 & DE$logFC >= log2(1.2)] = 'UP'
#tmp = DE %>%
#  dplyr::select(ensembl_gene_id, Comparison, Direction, Tissue) %>%
#  group_by(Tissue, Comparison, Direction) %>%
#  dplyr::summarise(FDR_0_05_FC_1.2 = length(unique(ensembl_gene_id))) %>%
#  spread(Direction, FDR_0_05_FC_1.2) 
#kable(tmp)
p = ggplot(DE, aes(y = -log10(adj.P.Val), x = logFC, color = Direction)) + geom_point() + xlim(c(-1,1))
p = p + scale_color_manual(values = c('green','grey','red')) + theme(legend.position='top')
p = p + facet_grid(Tissue+.~Comparison, scales = 'fixed')
p
all.diff.exp = c(all.diff.exp, list(Diagnosis = DE))
all.fit = c(all.fit, list(Diagnosis = FIT))
```

### Associate differential expression results with gc content, gene length and average expression
```{r associate.de, fig.height=15, fig.width=15}
pl = list()
pl[[1]] = ggplot(DE %>% dplyr::filter(Comparison == 'AD-CONTROL'), 
                 aes(x = log10(length), y = logFC, color = Direction)) + geom_point() 
pl[[1]] = pl[[1]] + geom_smooth(method = 'loess', inherit.aes = FALSE, aes(x = log10(length), y = logFC))
pl[[1]] = pl[[1]] + facet_grid(Tissue~.+Comparison) + scale_color_manual(values = c('green','grey','red'))
pl[[1]] = pl[[1]] + theme(legend.position = 'top')
pl[[2]] = ggplot(DE %>% dplyr::filter(Comparison == 'AD-CONTROL'), 
                 aes(x = percentage_gene_gc_content, y = logFC, color = Direction)) + geom_point()
pl[[2]] = pl[[2]] + geom_smooth(method = 'loess', inherit.aes = FALSE, aes(x = percentage_gene_gc_content, y = logFC))
pl[[2]] = pl[[2]] + facet_grid(Tissue~.+Comparison) + scale_color_manual(values = c('green','grey','red'))
pl[[2]] = pl[[2]] + theme(legend.position = 'top')
pl[[3]] = ggplot(DE %>% dplyr::filter(Comparison == 'AD-CONTROL'), 
                 aes(x = AveExpr, y = logFC, color = Direction)) + geom_point()
pl[[3]] = pl[[3]] + geom_smooth(method = 'loess', inherit.aes = FALSE, aes(x = AveExpr, y = logFC))
pl[[3]] = pl[[3]] + facet_grid(Tissue~.+Comparison) + scale_color_manual(values = c('green','grey','red'))
pl[[3]] = pl[[3]] + theme(legend.position = 'top')
multiplot(plotlist = pl, cols = 3)
```

### Differential expression analysis (with Tissue.APOE4 as primary variable)
Differential expression is performed on the primary variable by controlling for covariates identified above

Genes that are differentially expressed at an FDR <= 0.05 are
```{r diff.exp2, fig.height=15, fig.width=13}
# Get design matrix
DESIGN = getDesignMatrix(COVARIATES[, c(primaryVariable[3], postAdjustCovars), drop = F], Intercept = F)
DESIGN$design = DESIGN$design[,linColumnFinder(DESIGN$design)$indepCols]
# Re-estimate voom weights
VOOM.WEIGHTS = voom(cnts,
                    design=DESIGN$design, plot=F,
                    block = COVARIATES$individualIdentifier, 
                    correlation = correlation$cor)
# Fit linear model using new weights and new design
VOOM.WEIGHTS$E = CQN.GENE_EXPRESSION$E
FIT = lmFit(VOOM.WEIGHTS)
# Fit contrast
cntr = c()
for (region in c('FP', 'STG', 'PHG', 'IFG')){
  tmp = combn(paste0('Tissue.APOE4', region, '.', c('2', '1', '0')),2)
  cntr = c(cntr, apply(tmp, 2, paste, collapse = '-'))
}
contrast = makeContrasts(contrasts=cntr,
                         levels = colnames(FIT$coefficients))
FIT.CONTR = contrasts.fit(FIT, contrasts=contrast)
FIT.CONTR = eBayes(FIT.CONTR)
# Get differnetial expression
DE = lapply(1:dim(contrast)[2], function(i, FIT){
  topTable(FIT, coef=i, number = dim(FIT)[1], confint = T) %>%
    rownameToFirstColumn('ensembl_gene_id')
}, FIT.CONTR)
names(DE) = colnames(contrast)
DE = DE %>% 
  data.table::rbindlist(idcol = 'Comparison') %>%
  dplyr::mutate(Comparison = gsub('Tissue.APOE4','',Comparison),
                Study = 'MSSM',
                Sex = 'ALL') %>%
  tidyr::separate(Comparison, c('from.state','to.state'), sep = '-') %>%
  tidyr::separate(from.state, c('Tissue','reference'), sep = '\\.') %>%
  tidyr::separate(to.state, c('Tissue1','against'), sep = '\\.') %>%
  tidyr::unite(Comparison, reference, against, sep = '-') %>%
  dplyr::select(-Tissue1) %>%
  dplyr::left_join(GENE.PARAM %>%
                     dplyr::select(ensembl_gene_id, hgnc_symbol, percentage_gene_gc_content, length) %>%
                     unique())
DE$Direction = 'NONE'
DE$Direction[DE$adj.P.Val <= 0.05 & DE$logFC <= -log2(1.2)] = 'DOWN'
DE$Direction[DE$adj.P.Val <= 0.05 & DE$logFC >= log2(1.2)] = 'UP'
#tmp = DE %>%
#  dplyr::select(ensembl_gene_id, Comparison, Direction, Tissue) %>%
#  group_by(Tissue, Comparison, Direction) %>%
#  dplyr::summarise(FDR_0_05_FC_1.2 = length(unique(ensembl_gene_id))) %>%
#  spread(Direction, FDR_0_05_FC_1.2) 
#kable(tmp)
p = ggplot(DE, aes(y = -log10(adj.P.Val), x = logFC, color = Direction)) + geom_point() + xlim(c(-1,1))
p = p + scale_color_manual(values = c('green','grey','red')) + theme(legend.position='top')
p = p + facet_grid(Tissue+.~Comparison, scales = 'fixed')
p
all.diff.exp = c(all.diff.exp, list(APOE4 = DE))
all.fit = c(all.fit, list(APOE4 = FIT))
```

### Differential expression analysis (with Tissue.Diagnosis and Sex)
Differential expression is performed on the Tissue.Diagnosis x Sex variable by controlling for covariates identified above

Genes that are differentially expressed at an FDR <= 0.05 and folde change of 1.2 are
```{r diff.exp3, fig.height=15, fig.width=13}
## Modeling Diagnosis, msex and age_death conjointly
COVARIATES$Tissue.Diagnosis.Sex = paste(COVARIATES$Tissue.Diagnosis,COVARIATES$Sex, sep = '.') %>% factor
# Get design matrix
DESIGN = getDesignMatrix(COVARIATES[, c('Tissue.Diagnosis.Sex', setdiff(postAdjustCovars, 'Sex')), drop = F], 
                         Intercept = F)
DESIGN$design = DESIGN$design[,linColumnFinder(DESIGN$design)$indepCols]
# Re-estimate voom weights
VOOM.WEIGHTS = voom(cnts,
                    design=DESIGN$design, plot=F,
                    block = COVARIATES$individualIdentifier, 
                    correlation = correlation$cor)
# Fit linear model using new weights and new design
VOOM.WEIGHTS$E = CQN.GENE_EXPRESSION$E
FIT = lmFit(VOOM.WEIGHTS)
# Fit contrast
cntr = c('Tissue.Diagnosis.SexIFG.AD.MALE-Tissue.Diagnosis.SexIFG.CONTROL.MALE',
         'Tissue.Diagnosis.SexIFG.AD.FEMALE-Tissue.Diagnosis.SexIFG.CONTROL.FEMALE',
         'Tissue.Diagnosis.SexFP.AD.MALE-Tissue.Diagnosis.SexFP.CONTROL.MALE',
         'Tissue.Diagnosis.SexFP.AD.FEMALE-Tissue.Diagnosis.SexFP.CONTROL.FEMALE',
         'Tissue.Diagnosis.SexPHG.AD.MALE-Tissue.Diagnosis.SexPHG.CONTROL.MALE',
         'Tissue.Diagnosis.SexPHG.AD.FEMALE-Tissue.Diagnosis.SexPHG.CONTROL.FEMALE',
         'Tissue.Diagnosis.SexSTG.AD.MALE-Tissue.Diagnosis.SexSTG.CONTROL.MALE',
         'Tissue.Diagnosis.SexSTG.AD.FEMALE-Tissue.Diagnosis.SexSTG.CONTROL.FEMALE')
contrast = makeContrasts(contrasts=cntr,
                         levels = colnames(FIT$coefficients))
FIT.CONTR = contrasts.fit(FIT, contrasts=contrast)
FIT.CONTR = eBayes(FIT.CONTR)
# Get differnetial expression
DE = lapply(1:dim(contrast)[2], function(i, FIT){
  topTable(FIT, coef=i, number = dim(FIT)[1], confint = T) %>%
    rownameToFirstColumn('ensembl_gene_id')
}, FIT.CONTR)
names(DE) = colnames(contrast)
DE = DE %>% 
  data.table::rbindlist(idcol = 'Comparison') %>%
  dplyr::mutate(Comparison = gsub('Tissue.Diagnosis.Sex','',Comparison),
                Study = 'MSSM') %>%
  tidyr::separate(Comparison, c('from.state','to.state'), sep = '-') %>%
  tidyr::separate(from.state, c('Tissue','reference','Sex'), sep = '\\.') %>%
  tidyr::separate(to.state, c('Tissue1','against','Sex1'), sep = '\\.') %>%
  tidyr::unite(Comparison, reference, against, sep = '-') %>%
  dplyr::select(-Tissue1, -Sex1) %>%
  dplyr::left_join(GENE.PARAM %>%
                     dplyr::select(ensembl_gene_id, hgnc_symbol, percentage_gene_gc_content, length) %>%
                     unique())
DE$Direction = 'NONE'
DE$Direction[DE$adj.P.Val <= 0.05 & DE$logFC <= -log2(1.2)] = 'DOWN'
DE$Direction[DE$adj.P.Val <= 0.05 & DE$logFC >= log2(1.2)] = 'UP'
#tmp = DE %>%
#  dplyr::select(ensembl_gene_id, Comparison, Tissue, Direction, Sex) %>%
#  dplyr::group_by(Comparison, Tissue, Direction,Sex) %>%
#  dplyr::summarise(FDR_0_05_FC_1.2 = length(unique(ensembl_gene_id))) %>%
#  tidyr::spread(Direction, FDR_0_05_FC_1.2) 
#kable(tmp)
all.diff.exp = c(all.diff.exp, list(Diagnosis.Sex = DE))
all.fit = c(all.fit, list(Diagnosis.Sex = FIT))
```

### Differential expression analysis (with Tissue.Diagnosis and AOD)
Differential expression is performed on the Tissue.Diagnosis x AOD variable by controlling for covariates identified above

Genes that are differentially expressed at an FDR <= 0.05 and folde change of 1.2 are
```{r diff.exp4, fig.height=15, fig.width=13}
# Get design matrix
DESIGN = getDesignMatrix(COVARIATES[, c(primaryVariable[2], setdiff(postAdjustCovars, 'AOD')), drop = F], Intercept = F)
ind = grep('Diagnosis', colnames(DESIGN$design))
DESIGN$design[,ind] = DESIGN$design[,ind] * COVARIATES[rownames(DESIGN$design),'AOD']
DESIGN$design = DESIGN$design[,linColumnFinder(DESIGN$design)$indepCols]
colnames(DESIGN$design)[ind] = gsub('Tissue.Diagnosis', '', paste0(colnames(DESIGN$design)[ind], '.AOD'))
# Re-estimate voom weights
VOOM.WEIGHTS = voom(cnts,
                    design=DESIGN$design, plot=F,
                    block = COVARIATES$individualIdentifier, 
                    correlation = correlation$cor)
# Fit linear model using new weights and new design
VOOM.WEIGHTS$E = CQN.GENE_EXPRESSION$E
FIT = lmFit(VOOM.WEIGHTS)
# Fit contrast
cntr = c("FP.AD.AOD-FP.CONTROL.AOD",
         "IFG.AD.AOD-IFG.CONTROL.AOD",
         "PHG.AD.AOD-PHG.CONTROL.AOD",
         "STG.AD.AOD-STG.CONTROL.AOD")
contrast = makeContrasts(contrasts=cntr,
                         levels = colnames(FIT$coefficients))
colnames(contrast) = cntr
FIT.CONTR = contrasts.fit(FIT, contrasts=contrast)
FIT.CONTR = eBayes(FIT.CONTR)
# Get differnetial expression
DE = lapply(1:dim(contrast)[2], function(i, FIT){
  topTable(FIT, coef=i, number = dim(FIT)[1], confint = T) %>%
    rownameToFirstColumn('ensembl_gene_id')
}, FIT.CONTR)
names(DE) = colnames(contrast)
DE = DE %>% 
  data.table::rbindlist(idcol = 'Comparison') %>%
  dplyr::mutate(Study = 'MSSM', Sex = 'ALL') %>%
  tidyr::separate(Comparison, c('from.state','to.state'), sep = '-') %>%
  tidyr::separate(from.state, c('Tissue','reference','Sex'), sep = '\\.') %>%
  tidyr::separate(to.state, c('Tissue1','against','Sex1'), sep = '\\.') %>%
  tidyr::unite(Comparison, reference, against, sep = '-') %>%
  dplyr::select(-Tissue1, -Sex1, -Sex) %>%
  dplyr::left_join(GENE.PARAM %>%
                     dplyr::select(ensembl_gene_id, hgnc_symbol, percentage_gene_gc_content, length) %>%
                     unique())
DE$Direction = 'NONE'
DE$Direction[DE$adj.P.Val <= 0.05 & DE$logFC <= -log2(1.2)] = 'DOWN'
DE$Direction[DE$adj.P.Val <= 0.05 & DE$logFC >= log2(1.2)] = 'UP'
#tmp = DE %>%
#  dplyr::select(ensembl_gene_id, Tissue, Comparison, Direction) %>%
#  group_by(Comparison, Tissue, Direction) %>%
#  dplyr::summarise(FDR_0_05_FC_1.2 = length(unique(ensembl_gene_id))) %>%
#  spread(Direction, FDR_0_05_FC_1.2) 
#kable(tmp)
all.diff.exp = c(all.diff.exp, list(Diagnosis.AOD = DE))
all.fit = c(all.fit, list(Diagnosis.AOD = FIT))
#save.image('MSBB_Image.RData')
```


```{r synapse.parameters, include=FALSE, cache=TRUE}
parentId = 'syn22092490';
activityName = 'Covariate and Diagnosis Regression';
activityDescription = 'Covariate analysis and Regrsison of AD Diagnosis of aligned effective protien coding transcript level counts with CQN normalisation (IFG, STG, FP, PHG)';
thisFileName <- 'MSBB_TranscriptNorm.Rmd'
# Github link
thisRepo <- githubr::getRepo(repository = "Sage-Bionetworks/AD_TargetRank", ref="branch", refName='master')
thisFile <- githubr::getPermlink(repository = thisRepo, repositoryPath=paste0('code/prepscripts/',thisFileName))
```

### Store files in synapse
```{r synapse.store, include=FALSE, eval=TRUE, cache=FALSE}
activityName = 'Covariate and Diagnosis Regression';
activityDescription = 'Covariate analysis and Regrsison of AD Diagnosis of aligned effective protien coding transcript level counts with CQN normalisation (IFG, STG, FP, PHG)'
CODE <- syn_temp$store(synapseclient$Folder(name = "MSBB", parentId = parentId))
#Set Used SynIDs For Provenance
Syns_Used <- c("syn10507730", "syn6100548", "syn10156693", "syn6101474", "syn8698270", "syn22087693")
# Set annotations
all.annotations = list(
  dataType = 'mRNA',
  dataSubType = 'geneExp',
  summaryLevel = 'gene',
  assay	 = 'RNAseq',
  tissueTypeAbrv	= c('IFG', 'STG', 'FP', 'PHG'), 
  study = 'MSBB', 
  organism = 'HomoSapiens',
  consortium	= 'AMPAD',
  normalizationStatus	= TRUE,
  normalizationType	= 'CQN',
  rnaquantification = 'RSEM',
  genomeAssemblyID = 'GRCh38'
)
# Store SVA results
write.table(RESIDUAL.SVA.GENE_EXPRESSION, file = 'MSBB_SVA_Diagnosis_Corrected.tsv', sep = '\t', quote=F)
ENRICH_OBJ <-  syn_temp$store( synapseclient$File( path='MSBB_SVA_Diagnosis_Corrected.tsv', name = 'Normalised, covariates, surrogate and Diagnosis variable adjusted residual expression (for eQTL)', parentId=CODE$properties$id ), used = Syns_Used, activityName = activityName, executed = thisFile, activityDescription = activityDescription)
  all.annotations$dataSubType = 'residualGeneExpForeQTL'
  syn_temp$setAnnotations(ENRICH_OBJ, annotations = all.annotations)
# Store covariates
COVARIATES = rownameToFirstColumn(COVARIATES, 'SampleID')
write.table(COVARIATES, file = 'MSBB_SVA_Diagnosis_Covariates.tsv', row.names = F, sep = '\t', quote=F)
ENRICH_OBJ <-  syn_temp$store( synapseclient$File( path='MSBB_SVA_Diagnosis_Covariates.tsv', name = 'Covariates', parentId=CODE$properties$id ), used = Syns_Used, activityName = activityName, executed = thisFile, activityDescription = activityDescription)
  all.annotations$dataSubType = 'covariates'
  syn_temp$setAnnotations(ENRICH_OBJ, annotations = all.annotations)
 
# Store filtered counts
PROCESSED_COUNTS$filteredExprMatrix$counts %>%
  rownameToFirstColumn('ensembl_gene_id') %>%
  write.table(file = 'MSBB_Diagnosis_Regressed_Counts.tsv', sep = '\t', row.names=F, quote=F)
ENRICH_OBJ <-  syn_temp$store( synapseclient$File( path='MSBB_Diagnosis_Regressed_Counts.tsv', name = 'Counts (filtered raw)', parentId=CODE$properties$id ), used = Syns_Used, activityName = activityName, executed = thisFile, activityDescription = activityDescription)
  all.annotations$dataSubType = 'filteredCounts'
  syn_temp$setAnnotations(ENRICH_OBJ, annotations = all.annotations)
# Store Estimated counts
NEW.COUNTS %>%
  rownameToFirstColumn('ensembl_gene_id') %>%
  write.table(file = 'MSBB_Diagnosis_Regressed_eCounts.tsv', sep = '\t', row.names=F, quote=F)
ENRICH_OBJ <-  syn_temp$store( synapseclient$File( path='MSBB_Diagnosis_Regressed_eCounts.tsv', name = 'Counts (estimated)', parentId=CODE$properties$id ), used = Syns_Used, activityName = activityName, executed = thisFile, activityDescription = activityDescription)
  all.annotations$dataSubType = 'estimatedCounts'
  syn_temp$setAnnotations(ENRICH_OBJ, annotations = all.annotations)
# Store logCPM
CQN.GENE_EXPRESSION$y %>%
  rownameToFirstColumn('ensembl_gene_id') %>%
  write.table(file = 'MSBB_Diagnosis_Regressed_logCPM.tsv', sep = '\t', row.names=F, quote=F)
ENRICH_OBJ <-  syn_temp$store( synapseclient$File( path='MSBB_Diagnosis_Regressed_logCPM.tsv', name = 'Counts (filtered logCPM)', parentId=CODE$properties$id ), used = Syns_Used, activityName = activityName, executed = thisFile, activityDescription = activityDescription)
  all.annotations$dataSubType = 'filteredLCPM'
  syn_temp$setAnnotations(ENRICH_OBJ, annotations = all.annotations)
# Store cqn offsets
CQN.GENE_EXPRESSION$offset %>%
  rownameToFirstColumn('ensembl_gene_id') %>%
  write.table(file = 'MSBB_Diagnosis_Regressed_offset.tsv', sep = '\t', row.names=F, quote=F)
ENRICH_OBJ <-  syn_temp$store( synapseclient$File( path='MSBB_Diagnosis_Regressed_offset.tsv', name = 'Gene length and GC content offset', parentId=CODE$properties$id ), used = Syns_Used, activityName = activityName, executed = thisFile, activityDescription = activityDescription)
  all.annotations$dataSubType = 'offset'
  syn_temp$setAnnotations(ENRICH_OBJ, annotations = all.annotations)
# Store design matrix
MODEL1 %>%
  rownameToFirstColumn('SampleID') %>%
  write.table(file = 'MSBB_Diagnosis_Regressed_Design.tsv', sep = '\t', row.names=F, quote=F)
ENRICH_OBJ <-  syn_temp$store( synapseclient$File( path='MSBB_Diagnosis_Regressed_Design.tsv', name = 'Design Matrix', parentId=CODE$properties$id ), used = Syns_Used, activityName = activityName, executed = thisFile, activityDescription = activityDescription)
  all.annotations$dataSubType = 'designMatrix'
  syn_temp$setAnnotations(ENRICH_OBJ, annotations = all.annotations)
# Store surrogate variables
SURR.VAR %>%
  rownameToFirstColumn('SampleID') %>%
  write.table(file = 'MSBB_Diagnosis_Regressed_SurVar.tsv', sep = '\t', row.names=F, quote=F)
ENRICH_OBJ <-  syn_temp$store( synapseclient$File( path='MSBB_Diagnosis_Regressed_SurVar.tsv', name = 'Surrogate Variables', parentId=CODE$properties$id ), used = Syns_Used, activityName = activityName, executed = thisFile, activityDescription = activityDescription)
  all.annotations$dataSubType = 'surrogateVariables'
  syn_temp$setAnnotations(ENRICH_OBJ, annotations = all.annotations)
  
# Store residual gene expression for network analysis
RESIDUAL.NET.GENE_EXPRESSION %>%
  rownameToFirstColumn('ensembl_gene_id') %>%
  write.table(file = 'MSBB_Diagnosis_Regressed_netResidualExpression.tsv', sep = '\t', row.names=F, quote=F)
ENRICH_OBJ <-  syn_temp$store( synapseclient$File( path='MSBB_Diagnosis_Regressed_netResidualExpression.tsv', name = 'Normalised, covariates and Diagnosis removed residual expression (for network analysis)', parentId=CODE$properties$id ), used = Syns_Used, activityName = activityName, executed = thisFile, activityDescription = activityDescription)
  all.annotations$dataSubType = 'residualGeneExpForNetAnlz'
  syn_temp$setAnnotations(ENRICH_OBJ, annotations = all.annotations)

# Store DE Results
rbindlist(all.diff.exp, use.names = T, fill = T, idcol = 'Model') %>%
  write.table(file = 'MSSM_FP_STG_PHG_IFG_DiffExpression.tsv', sep = '\t', row.names=F, quote=F)

ENRICH_OBJ <-  syn_temp$store( synapseclient$File( path='MSSM_FP_STG_PHG_IFG_DiffExpression.tsv', name = 'Differential Expression Results (Tissue.Diagnosis)', parentId=CODE$properties$id ), used = Syns_Used, activityName = activityName, executed = thisFile, activityDescription = activityDescription)
  all.annotations$dataSubType = 'diffExp'
  syn_temp$setAnnotations(ENRICH_OBJ, annotations = all.annotations)
  
stopCluster(cl)
```

```{r DelFiles, echo=T, results='hide'}
system('rm *.tsv')
```
### R Source Code
[Github](`r thisFile`)

```{r knitmd, eval=FALSE, cache=FALSE, include=FALSE}
reticulate::use_python("/usr/bin/python", required = TRUE)
synapseclient <- reticulate::import("synapseclient")
syn_temp  <- synapseclient$Synapse()
syn_temp$login()
setwd("~/AD_TargetRank/code/")
source("~/AD_TargetRank/utilityFunctions/knitfile2synapseClient.R")
source("~/AD_TargetRank/utilityFunctions/hook_synapseMdSyntax_plot.R")
createAndKnitToFolderEntityClient(file = "MSBB_TranscriptNorm.Rmd",
                                          parentId ="syn22092490",
                                          folderName = 'MSBB')
```